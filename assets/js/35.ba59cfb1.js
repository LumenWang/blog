(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{433:function(t,s,v){"use strict";v.r(s);var a=v(2),_=Object(a.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("details",{staticClass:"custom-block details"},[v("summary",[t._v("1. 常用的集合有哪些？")]),v("p",[v("strong",[t._v("Map")]),t._v("接口和"),v("strong",[t._v("Collection")]),t._v("接口是所有集合框架的父接口：")]),t._v(" "),v("ul",[v("li",[t._v("Collection接口的子接口包括：Set接口和List接口；")]),t._v(" "),v("li",[t._v("Map接口的实现类主要有："),v("strong",[t._v("HashMap、ConcurrentHashMap、TreeMap、Hashtable")]),t._v("以及"),v("strong",[t._v("Properties")]),t._v("等；")]),t._v(" "),v("li",[t._v("Set接口的实现类主要有："),v("strong",[t._v("HashSet、LinkedHashSet、TreeSet")]),t._v("等；")]),t._v(" "),v("li",[t._v("List接口的实现类主要有："),v("strong",[t._v("ArrayList、LinkedList、Stack、Vector")]),t._v("等。")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("2. 静态变量和成员变量的区别？")]),v("ul",[v("li",[v("strong",[t._v("所属不同：")]),t._v(" 静态变量属于类，所以也成为类变量；成员变量属于对象，所有也成为实例变量（对象变量）；")]),t._v(" "),v("li",[v("strong",[t._v("在内存中出现的时间不同：")]),t._v(" 静态变量只在类创建时加载一次，随着类的加载而加载随着类的消失而消失；成员变量随着对象（也叫实例）的创建而存在，随着对象的消失而消失；")]),t._v(" "),v("li",[v("strong",[t._v("在内存中的位置不同：")]),t._v(" 静态变量存储于方法区里的静态区，成员变量属于对内存；")]),t._v(" "),v("li",[v("strong",[t._v("调用方式不同：")]),t._v(" 静态变量可以通过类名调用，也可以通过对象调用；成员变量只能通过对象调用；")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("3. filter过滤器用过吗？一般用在什么地方？")]),v("ul",[v("li",[t._v("用过")]),t._v(" "),v("li",[t._v("例如实现Servlet，Jsp或静态html等"),v("strong",[t._v("文件的拦截")]),t._v("，从而实现一些特殊功能。")]),t._v(" "),v("li",[t._v("例如实现URL级别的"),v("strong",[t._v("权限访问控制")]),t._v("、"),v("strong",[t._v("过滤敏感词汇")]),t._v("、压缩响应信息等一些高级功能。")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("4. 多线程一般用在什么地方？")]),v("ul",[v("li",[t._v("多线程的作用："),v("code",[t._v("充分利用CPU资源，提高CPU使用率")]),t._v("，才用多线程的方式去同时完成几件事情而不相互干扰")]),t._v(" "),v("li",[t._v("用在什么地方：大多情况下，用到多线程主要是需要处理"),v("code",[t._v("大量的IO操作")]),t._v("或处理需要"),v("code",[t._v("耗费大量时间的操作")]),t._v("等等。比如：读写文件等。")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("5. int和Integer的区别？")]),v("ul",[v("li",[t._v("Integer是int的包装类，而int是Java的一种基本数据类型")]),t._v(" "),v("li",[t._v("Integer是类，必须实例化之后才能使用，而int变量不需要")]),t._v(" "),v("li",[t._v("Integer的默认值是null，而int的默认值是0")]),t._v(" "),v("li",[t._v("Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针只想此对象；而int是直接存储数据值")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("6. 3.2E3F 里面的E/F分别表示什么？")]),v("ul",[v("li",[t._v("E：科学计数法\t3.2*10（3）")]),t._v(" "),v("li",[t._v("F:表示float类型")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("7. switch（参数） case的参数可以传哪些数据类型？")]),v("ul",[v("li",[t._v("jdk1.0\t char byte short int"),v("br"),t._v("\njdk5.0   enum(枚举)"),v("br"),t._v("\njdk7.0   String")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("8. do while 和while之间的区别？")]),v("ul",[v("li",[v("em",[v("strong",[t._v("do while")])]),t._v(" 先执行 然后在判断 保证程序至少执行一次【先斩后奏】")]),t._v(" "),v("li",[v("em",[v("strong",[t._v("while")])]),t._v(" 先判断 符合条件在执行")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("1. list用过哪些？ArrayList如何排序？list和Set的区别？")]),v("ul",[v("li",[t._v("用过ArrayList、LinkedList、Vector"),v("br")]),t._v(" "),v("li",[t._v("排序：sort()")])]),t._v(" "),v("blockquote",[v("p",[t._v("List和Set的区别：")]),t._v(" "),v("ol",[v("li",[t._v("List，Set都是继承自Collection接口")]),t._v(" "),v("li",[t._v("List特点：元素放入有顺序，元素可以重复。"),v("br"),t._v("\nSet特点：元素放入无顺序，元素不可重复，重复元素会覆盖。")]),t._v(" "),v("li",[t._v("Set和List对比："),v("br"),t._v("\nSet：检索元素效率低下，删除和插入效率高，删除和插入不会引起元素位置的改变。"),v("br"),t._v("\nList：和数组类似，List可以动态增长，查找元素效率高，增删元素效率低，因为增删元素会引起其他元素位置的改变。")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("2. 异常包括什么？说一下什么是运行时异常、非运行时异常，举例说明。")]),v("ul",[v("li",[v("p",[t._v("异常是指程序运行过程当中出现的例外情况")]),t._v(" "),v("p",[t._v("异常的体系结构：")]),t._v(" "),v("div",{staticClass:"language-mermaid line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("graph TB\n\tThrowable --\x3e Error\n\tThrowable --\x3e Exception\n\tException --\x3e RuntimeException\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])])])]),t._v(" "),v("p",[t._v("异常包括：运行时异常和非运行时异常")]),t._v(" "),v("ul",[v("li",[t._v("运行时异常(RuntimeException)：指编译能通过，直到运行的时候才体现出来")]),t._v(" "),v("li",[t._v("非运行时异常(Exception)：指在编译的时候必须明确该如何处理，否则根本无法通过编译")]),t._v(" "),v("li",[t._v("Error：描述了Java运行时系统的内部错误或资源耗尽错误。大多数错误与代码编写无关，而表示代码运行时JVM出现的问题。应用程序不应该抛出这种类型的对象。")])]),t._v(" "),v("p",[t._v("常见的运行时异常(RuntimeException)有：")]),t._v(" "),v("ol",[v("li",[t._v("IndexOutOfBoundsException（下标越界异常）")]),t._v(" "),v("li",[t._v("NullPointerException（空指针异常）")]),t._v(" "),v("li",[t._v("NumberFormatException（String转换为指定的数字异常）")]),t._v(" "),v("li",[t._v("ArithmeticException（算术异常，如除数为0）")]),t._v(" "),v("li",[t._v("FileNotFoundException（文件未找到异常）")]),t._v(" "),v("li",[t._v("IOException（操作输入流和输出流时可能出现的异常，如磁盘损坏等）")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("3. 线程的实现方式")]),v("ol",[v("li",[v("p",[v("strong",[t._v("继承Thread类")]),t._v("，重写run方法 (其实Thread类本身也实现了Runnable接口)")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("实现Runnable接口")]),t._v("， 重写run方法。（传入Thread类的构造方法中，由Thread的start启用线程）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("实现Callable接口")]),t._v("，重写call方法(有抛出异常和有返回值)")]),t._v(" "),v("p",[t._v("通过Callable和FutureTask创建线程，将Callable实现类传入FutureTask构造方法中，由FutureTask的start方法启用线程")])]),t._v(" "),v("li",[v("p",[t._v("通过线程池创建线程")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("4. 怎么处理异常")]),v("ul",[v("li",[t._v("抛还上级：throws")]),t._v(" "),v("li",[t._v("自行处理：try catch finally")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("5. 多态的实现机制")]),v("p",[v("strong",[t._v("Java中实现多态的机制靠的是：")]),t._v(" 父类或接口定义的引用变量可以指向子类或具体的实现类的实例对象，而程序调的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。")]),t._v(" "),v("blockquote",[v("p",[t._v("一句话："),v("strong",[t._v("父类或接口引用指向具体的实例对象")])])]),t._v(" "),v("p",[t._v("多态的不同表现形式：方法的重写和重载就是Java多态的不同表现")]),t._v(" "),v("ul",[v("li",[t._v("重写Overriding是父类与子类之间多态的一种表现")]),t._v(" "),v("li",[t._v("重载OverLoding是一个类中多态的一种表现")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("6. Java简单运算面试题")]),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("short")]),t._v(" x "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nx "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//左边short = 右边int？")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//报错")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("short")]),t._v(" y "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ny "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//y = (short)(y + 1); +=会自动转换")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("7. StringBuffer和StringBuilder之间的区别？")]),v("ul",[v("li",[t._v("StringBuffer和StringBuilder在创建对象的时候 都会多预留16块缓冲区")])]),t._v(" "),v("ol",[v("li",[v("em",[v("strong",[t._v("StringBuffer")])]),t._v(" 同一时间允许一个线程进行访问，"),v("strong",[t._v("效率较低")]),t._v("，但是"),v("strong",[t._v("不会出现并发错误")])]),t._v(" "),v("li",[v("em",[v("strong",[t._v("StringBuilder")])]),t._v(" 同一时间允许多个线程进行访问，"),v("strong",[t._v("效率较高")]),t._v("，但是"),v("strong",[t._v("可能会出现并发错误")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("8.  为什么不把一个类所有的方法全部定义成静态的呢？")]),v("ul",[v("li",[t._v("静态方法里面只能直接的访问静态成员")]),t._v(" "),v("li",[t._v("如果想要在静态方法里面访问非静态成员的话，需要先创建对象，拿着对象去调用")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("1. &和&&的区别")]),v("p",[t._v("&和&&都可以作为逻辑运算符使用")]),t._v(" "),v("p",[t._v("&&"),v("strong",[t._v("有短路特性")]),t._v("，当通过前面条件能够得知最终表达式结论的话，后面的条件会短路掉不做判断，所以"),v("strong",[t._v("效率更高")]),t._v("。&没有短路特性，两边的条件都会进行判断。")]),t._v(" "),v("p",[t._v("另外&还是按位运算符的"),v("strong",[t._v("按位与运算")]),t._v("。当&左右两边连接的是整数类型的时候作为二进制按位与运算，也就是将两个数的二进制位都是1的结果写1。")])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("2. final，finally，finalize的区别")]),v("ul",[v("li",[v("p",[v("strong",[t._v("final是一个修饰符")]),t._v("，可以用于修饰类、方法、变量")]),t._v(" "),v("p",[t._v("修饰类代表最终类，表示不能被继承"),v("br"),t._v("\n修饰方法代表最终方法，表示此方法不能被覆盖（但是可以被继承）"),v("br"),t._v("\n修饰表示引用地址或值不能被修改")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("finally是异常处理的语法结构")]),t._v("，表示无论是否出现异常最终都要执行的操作。")]),t._v(" "),v("p",[t._v("通常是释放和关闭资源的操作（如数据库连接和文件io流的关闭）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("finalize是Object类中的一个方法")]),t._v("，表示在gc回收对象之前会调用这个方法")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("3. String和StringBuffer的区别")]),v("p",[t._v("String和StringBuffer都是Java当中提供的字符串类型，其中String没有预留"),v("strong",[t._v("缓冲空间")]),t._v("，而StringBuffer会在原先内容的基础上预留一部分的缓冲空间。")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("String：")]),t._v(' "a" + "b" 相当于创建了一个新对象，返回值是”ab"。'),v("br"),t._v(" "),v("strong",[t._v("StringBuffer：")]),t._v(' sbuff.append("b")相当于还是在原先的对象上进行修改值。')])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("4. 请说出你所知道的线程同步的方法")]),v("ul",[v("li",[v("p",[t._v("synchronize修饰符")]),t._v(" "),v("p",[t._v("修饰代码块"),v("br"),t._v("\n修饰方法")])]),t._v(" "),v("li",[v("p",[t._v("java.util.concurrent.locks.ReentrantLock（并发包中的可重入锁）")]),t._v(" "),v("p",[t._v("Lock  lock = new ReentrantLock(); "),v("br"),t._v("\n其中lock.lock()用于上锁，lock.unLock()用于释放锁")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("5. 在Java中，如何跳出当前的多重循环")]),v("ol",[v("li",[v("p",[t._v("break加循环标签，如：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[t._v("example_this"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" x"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" x"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v(" example_this"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//结束循环")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br")])])]),t._v(" "),v("li",[v("p",[t._v("使用return")])]),t._v(" "),v("li",[v("p",[t._v("使用System.exit(0);结束虚拟机")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("6. 接口是否可以继承？抽象类时候可以实现接口？抽象类是否可以继承实体类？")]),v("p",[v("strong",[t._v("接口可以继承接口")]),t._v("，而且可以多继承，多个接口之间用"),v("code",[t._v(",")]),t._v("隔开；")]),t._v(" "),v("p",[v("strong",[t._v("抽象类可以实现接口")]),t._v("，而且可以暂时不实现接口当中要求的抽象方法，因为抽象类中本身就可以有抽象方法留待子类具体实现；")]),t._v(" "),v("p",[v("strong",[t._v("抽象类可以继承实体类")]),t._v("，如果继承的实体类没有默认的无参构造方法，需要写出抽象类的构造方法并在其构造方法的首行使用super()传参来明确指定调用父类的哪个构造方法。")])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("7. 抽象类是类 有构造方法 但是不能创建对象那么要构造方法的作用？")]),v("ul",[v("li",[t._v("给子类构造方法首行的super去调用的")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("1. ==和equals的区别？")]),v("ul",[v("li",[v("p",[v("strong",[t._v("==：是一个运算符")]),t._v("，用于比较两端的内容是否相等")]),t._v(" "),v("p",[t._v("基本数据类型：两端的值是否相等"),v("br"),t._v("\n引用类型：内存地址是否相等")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("equals：是Object类的一个方法")]),t._v("。子类继承这个方法之后可以按照自己的逻辑需求覆盖这个方法，从而描述自己的比较规则。\n例如：String类就将equals()方法覆盖为比较字符串的内容")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("2. 怎么解决死锁？")]),v("ul",[v("li",[t._v("wait()，notify()，notifyAll()")])]),t._v(" "),v("p",[t._v("使用 "),v("strong",[t._v("wait()")]),t._v(" 让当前线程(a)放弃锁标记进入等待池当中阻塞，从而成全另外的线程(b)能够成功获得它(b)需要的锁标记之后再调用 "),v("strong",[t._v("notify()")]),t._v(" 或者 "),v("strong",[t._v("notifyAll()")]),t._v(" 唤醒线程(a)，让线程(a)从等待池进入锁池等待获得锁标记")]),t._v(" "),v("blockquote",[v("p",[t._v("[注意这三个方法都必须已经持有锁标记才能调用所以他们只能出现在synchronized代码块当中]")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("3. 线程的生命周期")]),v("p",[t._v("新生 就绪 运行 消亡 阻塞（等待池 锁池）")])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("4. 线程池")]),v("ul",[v("li",[v("p",[v("strong",[t._v("可重用的线程池")]),t._v("，方法的参数表示同一时间允许多少个线程并发执行，当线程执行完时，线程将被归还给线程池  "),v("code",[t._v("Executors.newFixedThreadPool(2)")]),t._v(";")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("带缓存机制的线城池")]),t._v("，当线程执行完时，线程将被归还给线程池，如果一分钟之内没有其他线程被提交， 线程将会消亡  "),v("code",[t._v("Executors.newCachedThreadPool()")]),t._v(";")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("单一执行器")]),t._v("：同一时间仅允许一条线程执行  "),v("code",[t._v("Executors.newSingleThreadExcutor()")])])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("5. 简述JDBC中Statement和PrepareStatement的区别")]),v("ol",[v("li",[t._v("两者同为接口\t, "),v("strong",[t._v("PreparedStatement是Statement的子类")])]),t._v(" "),v("li",[t._v("Statement 只能执行静态语句\nPreparedStatement存在一个强大缓存区，相同的sql语句执行相同语句结构"),v("strong",[t._v("仅仅编译一次")]),t._v("，PreparedStatement仅对改动数据进行修改而不再进行编译，而Statement只要语句发生了改变，则必须重新进行编译")]),t._v(" "),v("li",[t._v("PreparedStatement支持对sql语句使用 "),v("strong",[t._v("?占位符")]),t._v("，杜绝了 sql注入安全隐患")]),t._v(" "),v("li",[t._v("如果sql语句不需要多次执行，或者?过多，则效率可能较Statement低")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("6. 简述 execute() executeUpdate() executeQuery() executeBatch()的使用场合，返回值?")]),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",[t._v("返回类型")]),t._v(" "),v("th",[t._v("使用场合")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("execute()")]),t._v(" "),v("td",[t._v("boolean")]),t._v(" "),v("td",[t._v("执行dql语句返回true，dml语句返回false")])]),t._v(" "),v("tr",[v("td",[t._v("executeUpdate()")]),t._v(" "),v("td",[t._v("int")]),t._v(" "),v("td",[t._v("执行dml返回更改记录数，dql立刻报错")])]),t._v(" "),v("tr",[v("td",[t._v("executeQuery()")]),t._v(" "),v("td",[t._v("ResultSet")]),t._v(" "),v("td",[t._v("执行dql语句返回结果集")])]),t._v(" "),v("tr",[v("td",[t._v("executeBatch()")]),t._v(" "),v("td",[t._v("int[]")]),t._v(" "),v("td",[t._v("只能执行dml语句，返回更改的记录数的数组")])])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("1. Java当中如何实现数据共享~")]),v("ol",[v("li",[t._v("使用"),v("strong",[t._v("静态变量")]),t._v("完成数据共享")]),t._v(" "),v("li",[t._v("使用"),v("strong",[t._v("参数传递")]),t._v("完成数据共享")]),t._v(" "),v("li",[t._v("使用"),v("strong",[t._v("内部类")]),t._v("完成数据共享")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("2. 为什么要使用内部类？")]),v("p",[t._v("​\t内部类是Java当中 "),v("u",[t._v("共享数据最最简单的方式之一")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("3. 内部类都有哪几种？")]),v("p",[t._v("​\t成员内部类、静态内部类、局部内部类、匿名内部类")])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("4. 如何自定义异常和如何主动制造异常出现的场景？")]),v("ul",[v("li",[v("p",[t._v("自定义异常")]),t._v(" "),v("p",[t._v("自己写一个类型"),v("strong",[t._v("继承Exception")]),t._v(" => 非运行时异常"),v("br"),t._v("\n自己写一个类型"),v("strong",[t._v("继承RuntimeException")]),t._v(" => 运行时异常")])]),t._v(" "),v("li",[v("p",[t._v("如何主动制造异常出现的场景")]),t._v(" "),v("p",[t._v("throw new 异常的类型();")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("5. throw 和 throws 的区别?")]),v("ul",[v("li",[v("p",[t._v("throw 用在方法体当中")]),t._v(" "),v("p",[t._v("在没有异常出现的情况下主动制造异常出现的场景\n​\t\t"),v("strong",[t._v("[没事找事型]")])])]),t._v(" "),v("li",[v("p",[t._v("throws 用在方法签名的最后")]),t._v(" "),v("p",[t._v("表明本方法当中出现指定种类的异常 本方法不做处理"),v("br"),t._v("抛还给调用的上级进行处理\n​\t\t"),v("strong",[t._v("[有事甩锅型]")])])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("6. 如何控制线程?")]),v("ol",[v("li",[v("em",[v("strong",[t._v("setPriority(int)")])]),t._v(" : 设置"),v("strong",[t._v("线程优先级别")]),t._v(" 可选范围 1-10 默认5"),v("br"),t._v("优先级越高 代表抢到时间片的概率越高")]),t._v(" "),v("li",[v("em",[v("strong",[t._v("static sleep(long)")])]),t._v(" : 让当前线程"),v("strong",[t._v("休眠")]),t._v("指定的毫秒数")]),t._v(" "),v("li",[v("em",[v("strong",[t._v("static yield()")])]),t._v(" : 让当前线程直接"),v("strong",[t._v("放弃时间片返回就绪")])]),t._v(" "),v("li",[v("em",[v("strong",[t._v("join()")])]),t._v(" : 当前线程邀请另一个线程"),v("strong",[t._v("优先执行")])])]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("7. 如何解决并发错误?")]),v("ul",[v("li",[v("strong",[t._v("synchronized")]),t._v("(临界资源){执行操作}")]),t._v(" "),v("li",[t._v("可重入锁java.util.concurrent.locks."),v("strong",[t._v("ReentrantLock")])])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("8. 如何解决死锁?")]),v("ul",[v("li",[v("p",[t._v("一块空间 : 等待池")])]),t._v(" "),v("li",[v("p",[t._v("三个方法 :")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("wait()")]),t._v(" : 让当前线程放弃已经持有的锁标记\n并且进入调用方法那个对象等待池当中")]),t._v(" "),v("li",[v("strong",[t._v("notify()")]),t._v(" : 从调用方法的那个对象的等待池当中\n随机的唤醒一个线程")]),t._v(" "),v("li",[v("strong",[t._v("notifyAll()")]),t._v(" : 从调用方法的那个对象的等待池当中\n唤醒所有线程")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("这三个方法不是线程类的 是Object类的"),v("br"),t._v("\n这三个方法必须在已经持有锁标记的前提下才能使用，否则不但失败 还会触发异常")])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("9. 锁池和等待池的区别？")]),v("ol",[v("li",[v("strong",[t._v("进入的时候")]),t._v("是否需要释放锁标记\n"),v("ul",[v("li",[t._v("锁池：不需要 所以可能会造成死锁")]),t._v(" "),v("li",[t._v("等待池：需要 先释放锁标记才能进入等待池")])])]),t._v(" "),v("li",[v("strong",[t._v("离开的时候")]),t._v("是否需要调用方法\n"),v("ul",[v("li",[t._v("锁池：不需要 只要锁标记再度可用")]),t._v(" "),v("li",[t._v("等待池：需要 必须要notify() 或 notifyAll()")])])]),t._v(" "),v("li",[v("strong",[t._v("离开之后")]),t._v("去往何方：\n"),v("ul",[v("li",[t._v("锁池：就绪")]),t._v(" "),v("li",[t._v("等待池：锁池")])])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("10. 流的分类?")]),v("ul",[v("li",[v("p",[v("strong",[t._v("按照方向分")]),t._v("：输入流 输出流")]),t._v(" "),v("p",[v("strong",[t._v("按照单位分")]),t._v("：字节流 字符流")]),t._v(" "),v("p",[v("strong",[t._v("按照功能分")]),t._v("：节点流 处理流（过滤流、包装流）")])])])]),v("h3",{attrs:{id:"list和map"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list和map"}},[t._v("#")]),t._v(" List和Map")]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("1. 接口和抽象类之间的区别？")]),v("ol",[v("li",[v("p",[t._v("分别表示的"),v("strong",[t._v("类型不同")])]),t._v(" "),v("p",[t._v("接口："),v("strong",[t._v("interface")]),v("br"),t._v("\n抽象类："),v("strong",[t._v("class")])])]),t._v(" "),v("li",[v("p",[t._v("里面"),v("strong",[t._v("定义的属性修饰符不同")])]),t._v(" "),v("p",[t._v("接口：里面定义的属性默认都是静态的最终变量（public static final）"),v("br"),t._v("\n抽象类：里面定义的属性默认是（default）")])]),t._v(" "),v("li",[v("p",[t._v("里面"),v("strong",[t._v("定义的方法不同")])]),t._v(" "),v("p",[t._v("接口：里面定义的方法默认都是抽象方法（public abstarct）"),v("br"),t._v("\n从 jdk8.0开始 接口里面可以定义普通方法"),v("br"),t._v("\n抽象类：里面既可以定义抽象方法 又可以定义普通方法")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("2. ArrayList和Vector之间的区别？")]),v("ul",[v("li",[v("p",[v("em",[v("strong",[t._v("Vector")])]),t._v("：同一时间允许单个线程进行访问 效率较低，但是不会出现并发错误"),v("br"),t._v(" "),v("em",[v("strong",[t._v("ArrayList")])]),t._v("：同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误")])]),t._v(" "),v("li",[v("p",[t._v("从jdk5.0开始 集合的工具类里面提供一个方法("),v("em",[v("strong",[t._v("synchronizedList")])]),t._v(") 可以将线程不安全的ArrayList对象变成线程安全的集合对象，于是Vector渐渐被淘汰")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("3. ArrayList和LinkedList之间的区别？")]),v("ul",[v("li",[v("p",[v("em",[v("strong",[t._v("ArrayList")])]),t._v("：底层基于"),v("strong",[t._v("数组")]),t._v("实现的")]),t._v(" "),v("p",[t._v("优点：随机访问 遍历查找效率高"),v("br"),t._v("\n缺点：添加/删除元素")])]),t._v(" "),v("li",[v("p",[v("em",[v("strong",[t._v("LinkedList")])]),t._v("：底层基于"),v("strong",[t._v("链表")]),t._v("实现的")]),t._v(" "),v("p",[t._v("优点：添加/删除元素效率高"),v("br"),t._v("\n缺点：随机访问/遍历查找效率低")])]),t._v(" "),v("li",[v("p",[t._v("*：当正常开发的时候 尽量避免使用LinkedList里面的get(下标)方法")])])])]),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("4. HashMap和Hashtable之间的区别？")]),v("ol",[v("li",[v("p",[t._v("同步特性不同：")]),t._v(" "),v("ul",[v("li",[v("em",[v("strong",[t._v("HashMap")])]),t._v(" 同一时间允许多个线程进行访问 "),v("strong",[t._v("效率较高")]),t._v("，但是"),v("strong",[t._v("可能会出现并发错误")])]),t._v(" "),v("li",[v("em",[v("strong",[t._v("Hashtable")])]),t._v(" 同一时间允许一个线程进行访问 "),v("strong",[t._v("效率较低")]),t._v("，但是"),v("strong",[t._v("不会出现并发错误")])]),t._v(" "),v("li",[t._v("从jdk5.0开始，集合的工具类里面提供一个方法（"),v("em",[v("strong",[t._v("synchronizedList")])]),t._v("） 可以将线程不安全的HashMap对象变成线程安全的集合对象")])])]),t._v(" "),v("li",[v("p",[t._v("对null的要求不同")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("HashMap无论主键还是值都可以存放null")]),t._v("，但是由于主键唯一 所以主键只能添加一个null")]),t._v(" "),v("li",[t._v("Hashtable无论主键还是值都不能装null，一旦泛型里面装null 都会触发NullPointerException")])])]),t._v(" "),v("li",[v("p",[t._v("底层分组不同：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("HashMap底层数组大小默认为16")]),t._v("，程序员可以随意的定义，但是最终一定是2的n次方数")]),t._v(" "),v("li",[t._v("Hashtable底层数组大小默认为11，程序员可以随意定义")])])]),t._v(" "),v("li",[v("p",[t._v("出现的版本不同")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("Hashtable：since jdk1.0")])]),t._v(" "),v("li",[v("strong",[t._v("HashMap：since jdk1.2")])])])])])]),v("h3",{attrs:{id:"泛型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("1. 泛型中的通配符 T，E，K，V，？")]),v("p",[t._v("本质上这些个都是通配符，没啥区别，换成 A-Z 之间的任何一个 字母都可以。"),v("br"),t._v("\n通常情况下，T，E，K，V，？ 是这样约定的：")]),t._v(" "),v("ul",[v("li",[t._v("？ 表示不确定的 java 类型")]),t._v(" "),v("li",[t._v("T (type) 表示具体的一个java类型")]),t._v(" "),v("li",[t._v("K V (key value) 分别代表java键值中的Key Value")]),t._v(" "),v("li",[t._v("E (element) 代表Element")])]),t._v(" "),v("blockquote",[v("p",[t._v("可参考："),v("a",{attrs:{href:"https://juejin.im/post/5d5789d26fb9a06ad0056bd9#heading-1",target:"_blank",rel:"noopener noreferrer"}},[t._v("掘金"),v("OutboundLink")],1)])])]),v("h3",{attrs:{id:"java基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java基础知识"}},[t._v("#")]),t._v(" java基础知识")]),t._v(" "),v("ol",[v("li",[t._v("栈和队列的区别")]),t._v(" "),v("li",[t._v("接口和抽象类的区别")]),t._v(" "),v("li",[t._v("int和Integer的区别")]),t._v(" "),v("li",[t._v("常量池的问题")]),t._v(" "),v("li",[t._v("==和equals的区别")]),t._v(" "),v("li",[t._v("重载和重写的区别")]),t._v(" "),v("li",[t._v("String和StringBuilder、StringBuffer的区别")])]),t._v(" "),v("h3",{attrs:{id:"集合框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集合框架"}},[t._v("#")]),t._v(" 集合框架")]),t._v(" "),v("ol",[v("li",[t._v("ArrayList,LinkedList,HashMap,LinkedHashMap,ConcurrentHashMap的底层实现原理")]),t._v(" "),v("li",[t._v("1.7版本和1.8版本的HashMap的区别")]),t._v(" "),v("li",[t._v("1.7版本和1.8版本的ConcurrentHashMap的区别")]),t._v(" "),v("li",[t._v("HashMap能不能排序？HashMap的长度为什么要是2的幂次方")])]),t._v(" "),v("h3",{attrs:{id:"多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),v("ol",[v("li",[t._v("创建线程的几种方式？wait,sleep分别是谁的方法，区别？线程间的通信方式？")]),t._v(" "),v("li",[t._v("介绍下什么是死锁，遇见过死锁吗？你是怎么排查的（可以通过jps排查）")]),t._v(" "),v("li",[t._v("创建线程池的几种方式，线程池有什么好处")]),t._v(" "),v("li",[t._v("线程继承和接口的区别，接口有什么好处")]),t._v(" "),v("li",[t._v("synchronized、Lock、ReentrantLock的区别，用法及原理")]),t._v(" "),v("li",[t._v("CountDownLatch与CyclicBarrier用法")]),t._v(" "),v("li",[t._v("ThreadLocal的用法和原理")]),t._v(" "),v("li",[t._v("volatile关键字的作用和原理")]),t._v(" "),v("li",[t._v("乐观锁和悲观锁")]),t._v(" "),v("li",[t._v("对公平锁，非公平锁，可重入锁，自旋锁，读写锁的理解")]),t._v(" "),v("li",[t._v("CAS是什么及基层原理")]),t._v(" "),v("li",[t._v("ArrayBlockQueue，LinkedBlockingQueue，SynchronousQueue等等阻塞队列的理解")]),t._v(" "),v("li",[t._v("ThreadPoolExecutor的传入参数及内部工作原理")]),t._v(" "),v("li",[t._v("给你一个具体的业务场景，让你使用ThreadPoolExecutor创建一个合适的线程池")]),t._v(" "),v("li",[t._v("分布式环境下，怎么保证线程安全")])]),t._v(" "),v("h3",{attrs:{id:"jvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[t._v("#")]),t._v(" jvm")]),t._v(" "),v("ol",[v("li",[t._v("JVM内存机制")]),t._v(" "),v("li",[t._v("介绍下垃圾收集机制，垃圾收集有哪些算法，各自的特点")]),t._v(" "),v("li",[t._v("聊聊GC，谈谈Major GC，Full GC区别，垃圾收集器有哪些，他们的区别")]),t._v(" "),v("li",[t._v("OutOfMemoryError这个错误你遇到过吗，你是怎么解决处理的")]),t._v(" "),v("li",[t._v("JVM调优有哪些参数，介绍下，线上环境上，你是怎么查看JVM的参数并进行调优的")]),t._v(" "),v("li",[t._v("能不能自己写一个类叫java. lang. String(类加载的过程，双亲委派模型)")])]),t._v(" "),v("h3",{attrs:{id:"框架相关问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#框架相关问题"}},[t._v("#")]),t._v(" 框架相关问题")]),t._v(" "),v("ol",[v("li",[t._v("Spring用了哪些设计模式？Spring注入bean的方式？对SpringIOC和SpringAOP的理解")]),t._v(" "),v("li",[t._v("Spring事务的隔离机制和传播机制")]),t._v(" "),v("li",[t._v("Mybatis的缓存机制（一级缓存和二级缓存），Mybatis的mapper文件中#和$的区别")]),t._v(" "),v("li",[t._v("SpringMVC的流程")]),t._v(" "),v("li",[t._v("Spring和SpringBoot的区别")]),t._v(" "),v("li",[t._v("对SpringBoot的理解")]),t._v(" "),v("li",[t._v("RPC框架有哪些，他们的区别")]),t._v(" "),v("li",[t._v("Dubbo的使用和理解")]),t._v(" "),v("li",[t._v("SprigCloud的使用和组件，谈谈你得理解")])]),t._v(" "),v("h3",{attrs:{id:"消息中间件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息中间件"}},[t._v("#")]),t._v(" 消息中间件")]),t._v(" "),v("ol",[v("li",[t._v("你们公司是如何进行消息中间件的技术选型")]),t._v(" "),v("li",[t._v("如何保证消息中间件的高可用")]),t._v(" "),v("li",[t._v("如何保证消息中间件重复发送消息")]),t._v(" "),v("li",[t._v("消息队列积压了大量的消息，你该怎么处理")]),t._v(" "),v("li",[t._v("如何保证消费者消费消极是有顺序的")]),t._v(" "),v("li",[t._v("让你来开发一个消息中间件，你会怎么架构")])]),t._v(" "),v("h3",{attrs:{id:"缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),v("ol",[v("li",[t._v("你们公司为什么要使用Redis，Redis有几种数据类型")]),t._v(" "),v("li",[t._v("Redis持久化机制，Redis的过期策略")]),t._v(" "),v("li",[t._v("怎么保证Redis的高可用")]),t._v(" "),v("li",[t._v("什么是缓存穿透，如何避免，什么是缓存雪崩，如何避免")]),t._v(" "),v("li",[t._v("如何保证缓存与数据库的读写一致性")]),t._v(" "),v("li",[t._v("Redis单线程模型原理，为什么能支撑高并发")]),t._v(" "),v("li",[t._v("Redis哨兵架构的理解和底层原理")])]),t._v(" "),v("h3",{attrs:{id:"数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[t._v("#")]),t._v(" 数据库")]),t._v(" "),v("ol",[v("li",[t._v("工作中你是怎么优化sql的")]),t._v(" "),v("li",[t._v("什么情况下，索引会失效")]),t._v(" "),v("li",[t._v("数据库的存储引擎，比如：MySQL的MyISAM和InnoDB区别")]),t._v(" "),v("li",[t._v("索引的最左原则")]),t._v(" "),v("li",[t._v("索引的底层原理")]),t._v(" "),v("li",[t._v("你们公司是怎么进行分库分表，分库分表的方案")])]),t._v(" "),v("h3",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),v("ol",[v("li",[t._v("分布式事务是怎么解决的")]),t._v(" "),v("li",[t._v("分布式session方案")]),t._v(" "),v("li",[t._v("设计一个秒杀场景")]),t._v(" "),v("li",[t._v("怎么防止表单多次提交")]),t._v(" "),v("li",[t._v("Linux的基本操作命令")]),t._v(" "),v("li",[t._v("ElasticSearch的使用和原理")]),t._v(" "),v("li",[t._v("zookeeper的使用和原理")])])])}),[],!1,null,null,null);s.default=_.exports}}]);